---
title: "Bias Adjust Example"
---

Below is an example applying the bias-adjustment approach to one well-sampled 250 km grid cell (either DC or LA).

Load and filter raw observations data

```{r}
library(dplyr)
library(ggplot2)
library(tidyr)

obs_data <- readRDS("_targets/objects/obs_gridded")
obs_data <- subset(obs_data, select = -c(geometry))
obs_data <- filter(obs_data, local_hour >= 7)
obs_data <- filter(obs_data, local_hour <= 20)
```

Find a cell with a lot of observations

```{r}

cells <- obs_data %>%
  group_by(cell) %>%
  summarise(n_obs=n(), lat=mean(decimalLatitude), lon=mean(decimalLongitude))

cell_id <- 178 #washington DC
```

Filter to that cell

```{r}

one_cell_data <- filter(obs_data, cell == cell_id)
  
sampling_effort <- one_cell_data %>%
  group_by(season, local_hour) %>%
  summarise(n_obs = n())

```

Make 4 GAMs one per season

```{r}

season_list <- c("1","2","3","4")
gam <- lapply(season_list, function(s) {
  df <- dplyr::filter(sampling_effort, season == s)
  m <- mgcv::gam(n_obs~s(local_hour), data=df, family = "poisson")
  pred_df <- data.frame(local_hour = 7:20)
  pred <- predict(m, pred_df)
  out <- data.frame(pred_df, effort = pred, season = s)
  return(out)
}) %>%
  bind_rows()

print(gam)

#Viz
gam %>%
  ggplot() +
  geom_col(aes(x=local_hour, y = effort), color = "black") +
  facet_wrap(~season) +
  ggtitle("Sampling Effort Across Seasons")
```

Append inverse effort back to original data

```{r}

one_cell_data <- one_cell_data %>%
  left_join(gam, by = c("local_hour", "season")) %>%
  dplyr::mutate(
    inverse_effort = 1/effort
  )
```

Look at a test species and compare adjusted and unadjusted data

```{r}

### Subsample -- test species. ----
testspecies <- one_cell_data %>%
  dplyr::filter(species == "Pieris rapae")

test <- testspecies %>%
  group_by(season) %>%
  dplyr::sample_n(size = nrow(testspecies), replace = T, weight = inverse_effort)

# Raw observation data.
testspecies %>%
  ggplot() +
  geom_bar(aes(local_hour), color = "black") +
  facet_wrap(~season) + 
  ggtitle("Raw Observation Activity Curves Per Season For Pieris rapae in Washington DC")

# subsampled observation data.
test %>%
  ggplot() +
  geom_bar(aes(local_hour), color = "black") +
  facet_wrap(~season) + 
  ggtitle("Adjusted Activity Curves Per Season For Pieris rapae in Washington DC")
```

Create bootstrap function

```{r}

my_bootstrap <- function(hours, inv_efforts, nbootstraps=50){
      bootstrap_medians <- numeric(nbootstraps)
      bootstrap_q10s <- numeric(nbootstraps)
      bootstrap_q90s <- numeric(nbootstraps)

      # Perform bootstrapping
      for (i in 1:nbootstraps) {
        sampled_hours <- sample(hours, replace=TRUE, size=length(hours), prob=inv_efforts)
        bootstrap_medians[i] <- median(sampled_hours)
        bootstrap_q10s[i] <- quantile(sampled_hours,0.1)
        bootstrap_q90s[i] <- quantile(sampled_hours,0.9)
      }

      # Calculate the 5th percentile, median, and 95th percentile
      median_lower <- quantile(bootstrap_medians, probs = 0.05)
      median_value <- median(bootstrap_medians)
      median_upper <- quantile(bootstrap_medians, probs = 0.95)

      q10_lower <- quantile(bootstrap_q10s, probs=0.05)
      q10_value <- median(bootstrap_q10s)
      q10_upper <- quantile(bootstrap_q10s, probs=0.95)

      q90_lower <- quantile(bootstrap_q90s, probs=0.05)
      q90_value <- median(bootstrap_q90s)
      q90_upper <- quantile(bootstrap_q90s, probs=0.95)

      # Return the results
      return(list(median_lower = median_lower, median_value = median_value, median_upper = median_upper,
                  q10_lower = q10_lower, q10_value = q10_value, q10_upper = q10_upper,
                  q90_lower = q90_lower, q90_value = q90_value, q90_upper = q90_upper))
    }
```

Apply to SSCs

```{r}

min_per_ssc <- 30
sscs <- one_cell_data %>%
  group_by(species, season) %>%
  filter(n() >= min_per_ssc) %>%
  summarize(
    bootstrap_results = list(my_bootstrap(local_hour, inverse_effort)),
    raw_median_value = median(local_hour),
    raw_q10_value = quantile(local_hour,0.1),
    raw_q90_value = quantile(local_hour,0.9),
  ) %>%
  unnest_wider(bootstrap_results) 
```

Visualize species

```{r}

mycolors <- c(summer = "#C5283D", winter = "#1C3144", monsoon = "#228B22")

species_list <- as.vector(unique(sscs$species))[1:10]
#species_list <- as.vector(species_list[1:10,])
sscs %>%
  filter(species %in% species_list) %>%
 # Filter original df to keep only rows of the sampled species
  #dplyr::arrange(desc(median)) %>%
  ggplot() +
  aes(y = species, yend = species, color = season) +
  #geom_segment(aes(x = lower_bound, xend = upper_bound),color = "blue", alpha = 0.5) +
  geom_point(aes(x = median_value), color = "blue", alpha = 0.5) +
  geom_segment(aes(x = q10_value, xend = q90_value),color = "blue", alpha = 0.5) +
  geom_point(aes(x = raw_median_value), color = "red", alpha = 0.5) +
  geom_segment(aes(x = raw_q10_value, xend = raw_q90_value),color = "red", alpha = 0.5) +
  #geom_point(aes(x = raw_median), color = "red", alpha = 0.5) +
  scale_color_manual(values = mycolors) +
  labs(title = "Median Shifts", 
       x = "Hour",
       y = "Common Name")
```

Putting it in a function

```{r}

library(dplyr)
library(ggplot2)
library(mgcv)

plot_bias_adjusted_density <- function(data,
                                       species,
                                       season,
                                       cell,
                                       year,
                                       min_hour = 7,
                                       max_hour = 20) {
  # 1. Filter data to the requested subset
  data_filtered <- data %>%
    filter(
      species == !!species,
      season == !!season,
      cell == !!cell,
      year == !!year,
      local_hour >= min_hour,
      local_hour <= max_hour
    )
  
  # If there's insufficient data after filtering, exit early
  if (nrow(data_filtered) < 1) {
    stop("No data found for the specified filters.")
  }
  
  # 2. Build the sampling-effort model (GAM)
  sampling_effort <- data_filtered %>%
    group_by(local_hour) %>%
    summarise(n_obs = n(), .groups = "drop")
  
  m <- mgcv::gam(n_obs ~ s(local_hour),
                 data = sampling_effort,
                 family = "poisson")
  
  # 3. Predict effort across the hour range
  pred_df <- data.frame(local_hour = min_hour:max_hour)
  pred    <- predict(m, pred_df, type = "response")
  gam_df  <- data.frame(local_hour = pred_df$local_hour, effort = pred)
  
  # 4. Calculate inverse effort
  data_adjusted <- data_filtered %>%
    left_join(gam_df, by = "local_hour") %>%
    mutate(inverse_effort = 1 / effort)
  
  # 5. Resample using inverse effort
  data_subsampled <- data_adjusted %>%
    sample_n(size = nrow(.), replace = TRUE, weight = inverse_effort)
  
  # 6. Compute quantiles for raw data vs. adjusted data
  raw_quantiles <- quantile(data_filtered$local_hour, probs = c(0.1, 0.5, 0.9))
  adj_quantiles <- quantile(data_subsampled$local_hour, probs = c(0.1, 0.5, 0.9))
  
  # 7. Create the two plots: raw vs. adjusted
  
  # Raw
  p_raw <- ggplot(data_filtered, aes(x = local_hour)) +
    geom_density(color = "black", fill = "gray80") +
    # Add vertical lines at 10th, 50th, 90th quantiles
    # Add vertical lines at 10th, 50th, 90th quantiles, with different colors
    geom_vline(xintercept = raw_quantiles[1], linetype = "dashed", color = "red",size=1.2) + 
    geom_vline(xintercept = raw_quantiles[2], linetype = "dashed", color = "orange", size=1.2) +
    geom_vline(xintercept = raw_quantiles[3], linetype = "dashed", color = "green", size=1.2) +
    theme_minimal() +
    labs(
      title = paste("Raw Activity Curves:", species),
      subtitle = paste("Cell =", cell,
                       "| Season =", season,
                       "| Year =", year),
      x = "Local Hour",
      y = "Count"
    )
  
  # Adjusted
  p_adjusted <- ggplot(data_subsampled, aes(x = local_hour)) +
    geom_density(color = "black", fill = "steelblue") +
    # Add vertical lines at 10th, 50th, 90th quantiles
    geom_vline(xintercept = adj_quantiles[1], linetype = "dotted") + 
    geom_vline(xintercept = adj_quantiles[2], linetype = "dotted") +
    geom_vline(xintercept = adj_quantiles[3], linetype = "dotted") +
    theme_minimal() +
    labs(
      title = paste("Bias-Adjusted Activity Curves:", species),
      subtitle = paste("Cell =", cell,
                       "| Season =", season,
                       "| Year =", year),
      x = "Local Hour",
      y = "Count"
    )
  
  # 8. Return or print the two plots (unlabeled dotted lines at 10th, 50th, 90th quantiles)
  list(raw_plot = p_raw, adjusted_plot = p_adjusted)
}


# Suppose your full dataset is in obs_data (similar to the original code),
# and you've already filtered times to 7â€“20 in that dataset or want the function to do so.


list_combos_for_species <- function(data, species_name) {
  data %>%
    filter(species == species_name) %>%
    group_by(season, cell, year) %>%
    summarize(
      n_observations = n(),
      cell_lat = mean(cell_lat),
      cell_long = mean(cell_lon),
      .groups = "drop"
    ) %>%
    arrange(desc(n_observations))
}

combos <- list_combos_for_species(obs_data, "Papilio glaucus")

# You can call:
results <- plot_bias_adjusted_density(
  data    = obs_data,
  species = "Papilio glaucus",
  season  = "2",          # e.g. "1" for Winter in your scheme
  cell    = 151,          # e.g. the "Washington DC" cell
  year    = 2021          # whichever year column you have in your dataset
)

test <- obs_data %>% group_by(species) %>% summarize(n=n())
# 'results' is a list with 2 ggplot objects, which you can display:
results$raw_plot
results$adjusted_plot
```
